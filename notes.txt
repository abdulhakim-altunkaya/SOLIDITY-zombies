★ pragma version means solidity compiler version 

★ state variables are stored on the contract storage. Which means they are written to Ethereum blockchain. 

★ uint = uint256 (256 bit unsigned integer)
2 ** 5 means 2 to the power of 5 which means 2*2*2*2*2

structs allow us to create more complex data types that can have multiple properties.
Creating a struct array is useful, it will act like a database on the blockchain. 

strings : arbitrary-length UTF-8 data.

★ Function parameter variable names start with "_" as a convention. 
private function names also start with "_" as a convention. 


★ pure functions do not read and change any data on the blockchain. 
view functions read data from the blockchain but do not change it. 

★ keccak256 hashing function converts the input to a random 256 bit hexadecimal number. It expects
a "bytes" data type input. For this reason we need to encode other data types.
keccak256 can be used for cryptography and also for (almost)random number generation. 

★ " array.push() - 1; " returns length of the array of minus-1.
It is the same as " array.length-1; "
uint someIndex = myArray.push("apple") -1; //This will return the index number of the apple, as it is the last element.

★ 
THE ADDRESS OF AN ACCOUNT (IN ETHEREUM):
Ethereum account = Bank account.
Ethereum address = Bank account number
Addresses are owned by users or smart contracts.

★ 
external    : NO main contract - YES inheriting+other contract
public      : YES main+inheriting contract  - YES other contract
internal    : YES main+inheriting contract - NO other contract
private     : YES main contract - NO inheriting+other contract

★ INTERFACE: If we want to read data from a contract that we do not own (which we cannot inherit from), we can use interface.

★ In Javascript a function can return only one value, In solidity a function can return multiple values.

★ GAS
The creators of Ethereum wanted to make sure someone couldn't clog up the network with an infinite loop, 
or hog all the network resources with really intensive computations. 
So they made it so transactions aren't free, and users have to pay for computation time as well as storage.

Normally there's no benefit to using these sub-types because Solidity reserves 256 bits of storage regardless of the uint size. 
For example, using uint8 instead of uint (uint256) won't save you any gas. But there's an exception to this: inside structs.
If you have multiple uints inside a struct, using a smaller-sized uint when possible will allow Solidity to pack 
these variables together to take up less storage. 

You'll also want to cluster identical data types together (i.e. put them next to each other in the struct) 
so that Solidity can minimize the required storage space. 

★NATIVE UNITS
block.timestamp : returns current timestamp
1 minutes       : 60
1 hours         : 3600
1 days          : 86400

Hakım lıkes hıs flower Ruta but sometımes he ıs a donkey. 
But he lıkes her a lotç You all should know ıt. Dont dıstur me. Now I am ın Lıthuanıa. And I love my flower a lot. 
